import { convertPixelSizeToWorldSize, divn } from "../helpers/utils";
class ClusterByGridMethod {
    constructor(gridSize) {
        this._nextFeatureIndex = 0;
        this._featureIdCharCache = {};
        this._gridSize = gridSize;
    }
    _getClusterSizeWorld(targetZoom) {
        return convertPixelSizeToWorldSize({ x: this._gridSize, y: 0 }, targetZoom).x;
    }
    _computeVisibleClusters(size, targetZoom, center) {
        const halfViewportSize = divn(convertPixelSizeToWorldSize(size, targetZoom), 2);
        const top = center.y + halfViewportSize.y;
        const bottom = center.y - halfViewportSize.y;
        const left = center.x - halfViewportSize.x;
        const right = center.x + halfViewportSize.x;
        const clusterSize = this._getClusterSizeWorld(targetZoom);
        const minBucketX = Math.floor(left / clusterSize);
        const maxBucketX = Math.ceil(right / clusterSize);
        const minBucketY = Math.floor(top / clusterSize);
        const maxBucketY = Math.ceil(bottom / clusterSize);
        const result = new Map();
        for (let x = minBucketX; x <= maxBucketX; x++) {
            for (let y = minBucketY; y <= maxBucketY; y++) {
                result.set(`${x}-${y}`, true);
            }
        }
        return result;
    }
    _clusterize(map, features, targetZoom) {
        const clusters = new Map();
        const clusterSize = this._getClusterSizeWorld(targetZoom);
        for (const feature of features) {
            const object = {
                world: map.projection.toWorldCoordinates(feature.geometry.coordinates),
                lnglat: feature.geometry.coordinates,
                clusterId: '',
                features: [feature]
            };
            const clusterX = Math.floor(object.world.x / clusterSize);
            const clusterY = Math.floor(object.world.y / clusterSize);
            const id = `${clusterX}-${clusterY}`;
            let cluster = clusters.get(id);
            if (!cluster) {
                cluster = { sumX: 0, sumY: 0, objects: [], features: [] };
                clusters.set(id, cluster);
            }
            cluster.sumX += object.world.x;
            cluster.sumY += object.world.y;
            cluster.objects.push(object);
            cluster.features.push(object.features[0]);
        }
        return clusters;
    }
    _generateClusterId(features) {
        const result = ['cluster-'];
        features.forEach(({ id }) => {
            if (!this._featureIdCharCache[id]) {
                this._featureIdCharCache[id] = String.fromCharCode(this._nextFeatureIndex);
                this._nextFeatureIndex += 1;
            }
            result.push(this._featureIdCharCache[id]);
        });
        return result.join('');
    }
    render({ map, features }) {
        const targetZoom = Math.round(map.zoom);
        const visibleClusters = this._computeVisibleClusters(map.size, targetZoom, map.projection.toWorldCoordinates(map.center));
        const currentCollection = this._clusterize(map, features, targetZoom);
        const nextViewportObjects = [];
        for (const [clusterId, cluster] of currentCollection.entries()) {
            if (!visibleClusters.get(clusterId))
                continue;
            const length = cluster.objects.length;
            if (length === 1) {
                nextViewportObjects.push({
                    ...cluster.objects[0],
                    clusterId: cluster.features[0].id
                });
            }
            else {
                const world = { x: cluster.sumX / length, y: cluster.sumY / length };
                nextViewportObjects.push({
                    world,
                    lnglat: map.projection.fromWorldCoordinates(world),
                    clusterId: this._generateClusterId(cluster.features),
                    features: cluster.features
                });
            }
        }
        return nextViewportObjects;
    }
}
export function clusterByGrid({ gridSize }) {
    return new ClusterByGridMethod(gridSize);
}
